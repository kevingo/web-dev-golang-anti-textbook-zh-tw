# 基礎網站程式設計

網站伺服器是一個程式，用來從一個 URL 中取得 request，並返回一個帶有內容的 response。這種 request-response 模式就是 HTTP 的協定。Go 語言完全支持 HTTP 協定，並且提供 `net/http` 的標準函式庫

HTTP 一開始是設計用來傳輸純文字，而後也允許傳輸多媒體內容。HTTP2 協定則是基於 HTTP1，它是一個 binary 的協定。

當我們在瀏覽器的網址列中輸入 `www.github.com` 時，會發生下面的事情：

1. 瀏覽器會幫你的網址加上 `https` 或 `http`，並在最後加上斜線。
2. 我們的 request 變成一個向 github.com 的 HTTP GET 請求。
3. 瀏覽器向 github.com 的 IP 位置發送 HTTP GET 請求 (請求 DNS 解析)。
4. Github 的網頁伺服器會處理該請求，並且將結果返回給呼叫的 IP 位置。
5. 瀏覽器會呈現返回的結果。

HTTP 的 response 會包含 HTTP 狀態碼。

狀態碼會告訴請求的客戶端關於 HTTP 伺服器處理的狀態。

下面是 HTTP/1.1 標準所定義的狀態碼：

- 1xx Informational
- 2xx Success
- 3xx Redirection
- 4xx Client Error
- 5xx Server Error

對於那些撰寫網站應用的開發者來說，這是一個大問題。但對於寫一個網站伺服器來說，他並不是什麼問題。對於底層來說，伺服器和一般的程式沒有什麼兩樣，他接受一個輸入，在資料庫中做些事情，並返回一些結果。返回的結果可能是空的，取決於呼叫的時候是正確還是非正確的。

瀏覽器只是提取使用者傳送 HTTP 請求和接收回應。我們可以完全手動模擬瀏覽器傳送和接收的過程，建構 HTTP 請求，並將其發送到伺服器端，接收 HTML 回應並且顯示它。對於網頁應用來說，會包含兩方面，瀏覽器端和 API 端。瀏覽器端的訪問是透過瀏覽器完成的，而 API 的訪問是透過程式端完成的。這兩種都使用 HTTP 的 request-response 模式，但使用 API 我們可以自動化很多事情。

##HTTP 方法
HTTP 的 request-response 是透過 HTTP 方法完成。

這裡列舉四種 HTTP 方法：GET、POST、DELETE、PUT。

GET :   用來存取一個網址。`GET /` 會取得主頁。
POST:   用來建立儲存在對應網址上的資料。
PUT:    用來更新在對應網址上的資料。
DELETE: 用來刪除對應網址上的資料。

    // 建立一個新的 categories
    // POST /categories

    // 更新一個已經存在的 category
    // PUT /categories/12

    // 瀏覽一個 category 的詳細資料
    // GET /categories/12   

    // 刪除一個已經存在的 category
    // DELETE /categories/12

把 category 想成一個文件，POST 用來建立它、GET 用來取得它的資訊、PUT 用來更新它的資訊，而 DELETE 則是刪除它。對於刪除來說，我們不應該用 GET `/delete/1234`，而應該用 DELETE `/tasks/1234`。

這其中的差別不在於語意上的不同，的確所有的行為都可以用 GET 請求。GET 不需要驗證，如果我寫一個 Go 的程式是送一個 GET /delete/<id>，而 id 從 0 到一個很大的數字，那我可以把我的應用上的資料都刪掉。當然，我們也可以發送一個 DELETE <id> 的請求好幾百萬次。GET 是預設用來從伺服器上取得資料，它不應該用在其他的事情上。

#### GET vs POST
Apart from their functional differences, GET and POST differ in security perspectives. Both are insecure.

GET transfers data via the URL. POST sends data in the request's body or payload, but that isn't hidden or encrypted by default, but it isn't visible on the URL, it is easily accessible to anyone who knows how to read a HTTP request.

Security is something you build your application around. There isn't much difference between GET and POST when we consider security, both transfer data in plain text GET is just relatively a little less secure since URLs are logged by a proxy server/firewall/browser history and that GET requests can be done by the browser on behalf of the user without confirmation. Bots are common over the internet, bots can visit randomly to every link present in your application, but they don't send random data to any Form you have, or if so, very few bots can do that.

For protecting data of the webapp, one has to stick to using HTTPS and sanitize any data that comes from the user.

##### Example

A blog consists of a collection of posts, a post has tags, is written by some author, at some time and has some primary key
to uniquely identify it in our database and it has a slug which means the URL.

This is the era of semantic web, thus the new beautiful URLs like, `surajblog.com/posts/welcome-the-new-year`,
the slug is the `welcome-the-new-year`.

When the server gets a HTTP GET request of `/posts/welcome-the-new-year`, it'll search for URL handlers starting with the list of URL
handlers we have given, then it'll find the closest match, in our case it'll be `/post/`, then it'll call the handler of this URL.

Our `/` root URL should be at the very bottom of our list. Because while executing, checks are done from top to bottom.

        //sample handler definition
        http.HandleFunc("/post/", ShowPostBySlug)
        http.HandleFunc("/", ShowAllPosts)

Handler talk to the database, fetch the data and render templates which show up as HTML pages in our browser.

## What is a template?

Templates are a way to present data to the user. The server populated the templates and sends the HTML page back to the browser. For a blog, it doesn't make sense to use a separate html page for each post. This is why there is a post template and the server will get all the details like content, title, date published and populate the post template and return it back to the browser.

A web application is basically a way of representing data stored in the database to the end user using HTTP.

Writing a web application:
1. Fix the database structure.
2. Understand how data flows and decide the URLs.
3. Write templates to corresponding to each URL set.
4. Write functions in Go to handle each URL pattern, called `handlers`.
5. Handlers fetch data from the database and populate data in the templates.

###### Not abusing templates
The logic behind creating templates was to not to repeat HTML code. Templates support variables which our handlers are going to use. The standard way is to handle the business login inside the handler and use templates just for rendering the data. Templates are to be used only for the presentation logic *not* the business logic. It becomes difficult to maintain applications which have business logic inside the template. It should never be done and is a very bad programming practice.

####Example:
We are going to build a todo list manager in this book. It support multiple users.

Wrong way: Fetch all tasks in the template and only show those of the current user. i.e. filter the tasks in the template
Correct way: Fetch only the tasks belonging to the current user. i.e. filter the tasks in the handler.

Functionality of our *EditTask* URL which is `/edit/<id>`.

file `views/addViews.go`

```golang
//EditTaskFunc is our handler which will handle the /edit/<id> URL
func EditTaskFunc(w http.ResponseWriter, r *http.Request) {
        //Code
        task := db.GetTaskByID(id)
        editTemplate.Execute(w, task)
        //Code
}
```

file `db/tasks.go`
```golang
func GetTaskByID(id int) types.Context {
        //Code to fetch tasks of the current user
        context := types.Context{Tasks: tasks}
        return context
}
```

The EditTaskFunc talks to the database with the GetTaskByID function and fetches the tasks for the current user and populates the editTemplate.

Thus we can split an application into views, database, templates and controller(main package).

## Static Files
Static files are the CSS/JS/Images which we load into our html templates.

The URL which responds to static files will be `/static/`.

Execution:
1. We get a request like `/static/<filepath>`
2. We go to the public directory of our application and look for <filepath>
3. If we get a file of that path then we serve the file, othewise send a 404 error.

The `public` folder contains all your static files. We will have a templates folder on the same folder where the public is present.

The reason templates is a separate folder is that it is a separate entity and shouldn't be publicly available using the /static/ URL.

        public
        |   |-- static
        |   |   |-- css
        |   |   |   `-- styles.css
                        ..and more
        |   |   `-- js
        |   |       |-- bootstrap.min.js
        |   |       .... and more
        templates
        |   |-- completed.html
        |   |   ...and more        

##### Note Output
The above output is of the `tree` program.

#####連結

-[前一章節](1.0generalTalk.md)
-[下一章節](2.0implementationBasics.md)