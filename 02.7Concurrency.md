# 並行

#### goroutine

goroutine 和並行是 Go 語言的核心。它們和執行緒很像，但執行方式卻不同。也許超過數千個的 goroutine 背後只有 5 或 6 個執行緒在負責。Go 語言同時支援你的 goroutine 之間互相使用記憶體。一個 goroutone 通常使用 4~5 KB 的 stack 記憶體。因此，要在一台電腦上同時執行上千個 goroutine 並不困難。Goroutone 相對於執行緒來說更為輕量、有效率且更容易使用。

Goroutine 在執行時期由執行緒來管理。我們可以使用 `go` 這個關鍵字來建立一個新的 goroutine ( *main() 函式也是一個 goroutone*)。

	go hello(a, b, c)
	
來看一個例子。

```golang
package main

import (
	"fmt"
	"runtime"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		runtime.Gosched()
		fmt.Println(s)
	}
}

func main() {
	go say("world") // 建立一個新的 goroutine
	say("hello") // 目前的 goroutine
}
```

輸出：

	hello
	world
	hello
	world
	hello
	world
	hello
	world
	hello
	
我們看到在 Go 中要使用 goroutine 是很容易的，只要用 `go` 關鍵字即可。在上面的例子中使用到的兩個 goroutines 共享同樣的記憶體空間，但我們最好記住：不要在 goroutine 之間共享資料，要使用 channel 來共享資料。

`runtime.Gosched()` 指的是讓 CPU 執行其他的 goroutine，之後在某個時間點後再回來。

這裡的 scheduler 只用一個執行緒來跑所有的 goroutines，意味著我們只實現了並行。如果你想要用多個 CPU 來發揮平行處理的優勢的話，你可以呼叫 runtime.GOMAXPROCS 來設置要使用幾個 CPU。如果 `n<1` 時，什麼都不會改變。這個函式可能未來會被移除，針對並行和平行處理的更多細節，你可以參考[這篇文章](http://concur.rspace.googlecode.com/hg/talk/concur.html#landing-slide)。

#### channels

goroutines run in the same memory address space, so you have to maintain synchronization when you want to access shared memory. How do you communicate between different goroutines? Go uses a very good communication mechanism called `channel`. `channel` is like a two-way pipeline in Unix shells: use `channel` to send or receive data. The only data type that can be used in channels is the type `channel` and the keyword `chan`. Be aware that you have to use `make` to create a new `channel`.

```golang
ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
```
	
channel uses the operator `<-` to send or receive data.

```golang
ch <- v    // send v to channel ch.
v := <-ch  // receive data from ch, and assign to v
```
	
Let's see more examples.

```golang
package main

import "fmt"

func sum(a []int, c chan int) {
	total := 0
	for _, v := range a {
	total += v
	}
	c <- total  // send total to c
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)
	x, y := <-c, <-c  // receive from c

	fmt.Println(x, y, x + y)
}
```

Sending and receiving data in channels blocks by default, so it's much easier to use synchronous goroutines. What I mean by block is that a goroutine will not continue when receiving data from an empty channel, i.e (`value := <-ch`), until other goroutines send data to this channel. On the other hand, the goroutine will not continue until the data it sends to a channel, i.e (`ch<-5`), is received. 

#### Buffered channels

I introduced non-buffered channels above. Go also has buffered channels that can store more than a single element. For example, `ch := make(chan bool, 4)`, here we create a channel that can store 4 boolean elements. So in this channel, we are able to send 4 elements into it without blocking, but the goroutine will be blocked when you try to send a fifth element and no goroutine receives it.

```golang
ch := make(chan type, n)

n == 0 ! non-buffer（block）
n > 0 ! buffer（non-block until n elements in the channel）
```
	
You can try the following code on your computer and change some values.

```golang	
package main

import "fmt"

func main() {
	c := make(chan int, 2)  // change 2 to 1 will have runtime error, but 3 is fine
	c <- 1
	c <- 2
	fmt.Println(<-c)
	fmt.Println(<-c)
}
```
	
#### Range and Close

We can use range to operate on buffer channels as in slice and map.

```golang
package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
	x, y := 1, 1
	for i := 0; i < n; i++ {
		c <- x
		x, y = y, x + y
	}
	close(c)
}

func main() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)
	for i := range c {
		fmt.Println(i)
	}
}
```
	
`for i := range c` will not stop reading data from channel until the channel is closed. We use the keyword `close` to close the channel in above example. It's impossible to send or receive data on a closed channel; you can use `v, ok := <-ch` to test if a channel is closed. If `ok` returns false, it means the there is no data in that channel and it was closed.

Remember to always close channels in producers and not in consumers, or it's very easy to get into panic status.

Another thing you need to remember is that channels are not like files. You don't have to close them frequently unless you are sure the channel is completely useless, or you want to exit range loops. 

#### Select

In the above examples, we only use one channel, but how can we deal with more than one channel? Go has a keyword called `select` to listen to many channels.

`select` is blocking by default and it continues to execute only when one of channels has data to send or receive. If several channels are ready to use at the same time, select chooses which to execute randomly.

```golang
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 1, 1
	for {
		select {
		case c <- x:
			x, y = y, x + y
		case <-quit:
		fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
```	
`select` has a `default` case as well, just like `switch`. When all the channels are not ready for use, it executes the default case (it doesn't wait for the channel anymore).
```golang
select {
case i := <-c:
	// use i
default:
	// executes here when c is blocked
}
```	
#### Timeout

Sometimes a goroutine becomes blocked. How can we avoid this to prevent the whole program from blocking? It's simple, we can set a timeout in the select.
```golang
func main() {
	c := make(chan int)
	o := make(chan bool)
	go func() {
		for {
			select {
				case v := <- c:
					println(v)
				case <- time.After(5 * time.Second):
					println("timeout")
					o <- true
					break
			}
		}
	}()
	<- o
}
```
####Runtime goroutine

The package `runtime` has some functions for dealing with goroutines.

- `runtime.Goexit()`

	Exits the current goroutine, but defered functions will be executed as usual.
	
- `runtime.Gosched()`

	Lets the scheduler execute other goroutines and comes back at some point.
	
- `runtime.NumCPU() int`

	Returns the number of CPU cores

- `runtime.NumGoroutine() int`

	Returns the number of goroutines

- `runtime.GOMAXPROCS(n int) int`

	Sets how many CPU cores you want to use

#####連結

-[前一章節](02.6Interface.md)
-[下一章節](1.0generalTalk.md)